// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections;

namespace madlib
{
	public interface IRenderable
	{
		string Value();
		bool IsQTE ();
	}

	public class Entry : IRenderable {
		private string _value;
		private EntryStore _store;
		public string Type{ get; set; }

		public Entry(string type)
		{
			Type = type;
		}

		public EntryStore Store
		{
			get
			{
				if (_store == null)
				{
					_store = EntryStore.Instance;
				}
				return _store;
			}

			set
			{
				_store = value;
			}
		}


		public string Value()
		{
			if (_value == null) {
				_value = Store.GetRand(Type);
			}
			return _value;
		}

		public bool IsQTE()
		{
			return false;
		}
	}

	public class Text : IRenderable {
		public string Content;
		public string Value()
		{
			return Content;
		}

		public Text(string content)
		{
			Content = content;
		}

		public bool IsQTE()
		{
			return false;
		}
	}

	public class QuickTimeEvent : IRenderable {
		public string Content;
		public QuickTimeEvent(string content)
		{
			Content = content;
		}

		public string Value()
		{
			return "%" + Content;
		}

		public bool IsQTE()
		{
			return true;
		}


	}

	public class EntryStore
	{
		private static EntryStore singleton;

		public static EntryStore Instance
		{
			get
			{
				if (singleton == null) {
					singleton = new EntryStore ();
				}
				return singleton;
			}
		}


		private Hashtable lookup = new Hashtable ();

		public void Clear()
		{
			lookup.Clear ();
		}

		public IList AllFor(string type)
		{
			return (IList)lookup[type];
		}

		public void Add(string type, string value)
		{
			IList entries = (IList)lookup [type];
			if (entries == null)
			{
				entries = new ArrayList();
				lookup[type] = entries;
			}
			entries.Add (value);
		}

		public void AddMultiple(string type, string[] values)
		{
			foreach (string value in values) {
				Add (type, value);
			}
		}

		public bool IsEntry(string type)
		{
			return lookup.ContainsKey (type);
		}

		public string GetRand(string type)
		{
			IList values = AllFor (type);
			Random rand = new Random ();
			int index = rand.Next (0, values.Count);
			return (string)values [index];
		}
	}

	public class Template
	{
		public ArrayList Renderers { get; set; }
		private string _renderedText;

		public Template()
		{
			Renderers = new ArrayList ();
		}

		public string Render()
		{
			if(_renderedText == null)
			{
				_renderedText = "";
				foreach(IRenderable renderable in Renderers)
				{
					_renderedText += renderable.Value();
				}
		    }
			return _renderedText;
		}

		public void Add(IRenderable renderer)
		{
			Renderers.Add (renderer);
		}
	}

	public class Madlib
	{
		public static Template Parse(string templateString)
		{
			EntryStore s = EntryStore.Instance;
			Template t = new Template ();
			string[] extracted = templateString.Split (new char[]{'|'});
			foreach(string item in extracted)
			{
				if(item.Length < 0)
				{
					continue;
				}
				if(s.IsEntry(item))
				{
					t.Add (new Entry(item));
				}
				else
				{
					t.Add (new Text(item));
				}
			}

			return t;
		}
	}
}

